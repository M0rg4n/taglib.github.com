---
layout: api
title: TagLib: TagLib::ByteVector Class Reference (TagLib)
header: 1.8.0 (TagLib: TagLib::ByteVector Class Reference)
---
<!-- Generated by Doxygen 1.7.3 -->
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceTagLib.html">TagLib</a>      </li>
      <li class="navelem"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a>      </li>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#related">Related Functions</a>  </div>
  <div class="headertitle">
<h1>TagLib::ByteVector Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="TagLib::ByteVector" -->
<p>A byte vector.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="tbytevector_8h_source.html">tbytevector.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for TagLib::ByteVector:</div>
<div class="dyncontent">
<div class="center"><img src="classTagLib_1_1ByteVector__coll__graph.png" border="0" usemap="#TagLib_1_1ByteVector_coll__map" alt="Collaboration graph"/></div>
<map name="TagLib_1_1ByteVector_coll__map" id="TagLib_1_1ByteVector_coll__map">
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classTagLib_1_1ByteVector-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#af6e5b2614dacfc049b5b6e32063d4aa1">ByteVector</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a6e3bb27e43b76a1e3e40c8364ad7158c">ByteVector</a> (<a class="el" href="namespaceTagLib.html#a0d56da3fb97ff5e823c2c4b3aea77e25">uint</a> size, char value=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a613e5467e1b582775f98eed1e2f6c1ef">ByteVector</a> (const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#aa286e2ae6447e55e85ef855838d10c96">ByteVector</a> (char c)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#ad3fee04984a628e55cf480d56604e9ce">ByteVector</a> (const char *data, <a class="el" href="namespaceTagLib.html#a0d56da3fb97ff5e823c2c4b3aea77e25">uint</a> length)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#aa3cd4cd25e6b8fbd6a795005478b08e0">ByteVector</a> (const char *data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a34b45e9a86728313ddef12a037acc73d">~ByteVector</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a3749ede91c16089c33992649eb0522c8">setData</a> (const char *data, <a class="el" href="namespaceTagLib.html#a0d56da3fb97ff5e823c2c4b3aea77e25">uint</a> length)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#af9a5128d1503ddaf6e6f780ce4eeb184">setData</a> (const char *data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a55d40ed1e9b9749e3895c845f1f26901">data</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#affe39991f59ce978639ef48400b0891b">data</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#ab347f103e6c2bba92fdf491031dc46ba">mid</a> (<a class="el" href="namespaceTagLib.html#a0d56da3fb97ff5e823c2c4b3aea77e25">uint</a> index, <a class="el" href="namespaceTagLib.html#a0d56da3fb97ff5e823c2c4b3aea77e25">uint</a> length=0xffffffff) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a4db625889dc6281783ae25d3733e0919">at</a> (<a class="el" href="namespaceTagLib.html#a0d56da3fb97ff5e823c2c4b3aea77e25">uint</a> index) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a557c662441974ba731bfdf9a360df5ce">find</a> (const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;pattern, <a class="el" href="namespaceTagLib.html#a0d56da3fb97ff5e823c2c4b3aea77e25">uint</a> offset=0, int byteAlign=1) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a46c984d49bda6a270f62d98b6a2933e4">rfind</a> (const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;pattern, <a class="el" href="namespaceTagLib.html#a0d56da3fb97ff5e823c2c4b3aea77e25">uint</a> offset=0, int byteAlign=1) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#ab62281faaa15a69073f4b830ad576213">containsAt</a> (const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;pattern, <a class="el" href="namespaceTagLib.html#a0d56da3fb97ff5e823c2c4b3aea77e25">uint</a> offset, <a class="el" href="namespaceTagLib.html#a0d56da3fb97ff5e823c2c4b3aea77e25">uint</a> patternOffset=0, <a class="el" href="namespaceTagLib.html#a0d56da3fb97ff5e823c2c4b3aea77e25">uint</a> patternLength=0xffffffff) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a5f330306a73bbd23d89f7c14a2126456">startsWith</a> (const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;pattern) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a68505e709c3cc3061ca0de7a04251f46">endsWith</a> (const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;pattern) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#adf2c71ba84454616e1310e6dc12f8aa8">replace</a> (const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;pattern, const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;with)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#afe9d03a684dbba770e2871a2dfe1d55a">endsWithPartialMatch</a> (const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;pattern) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#aff38e54fa184e9cf0c77182db200a6e4">append</a> (const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a2e2e95380834f3a55d49df208befe88c">clear</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceTagLib.html#a0d56da3fb97ff5e823c2c4b3aea77e25">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#ad35dc30632085e7696660de9694bbc24">size</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#add7490c1075ad2e119a164fb5491fd44">resize</a> (<a class="el" href="namespaceTagLib.html#a0d56da3fb97ff5e823c2c4b3aea77e25">uint</a> size, char padding=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a99848a9fbcb7b39e16866a881e2b115f">begin</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ConstIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#aab4c8b26244d1efc6f392062a3146e41">begin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a53a1f28d1a51f7351733f2ef22090c34">end</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ConstIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#acc7a47ae21af8e3a02be6346c078f2b8">end</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a3ab3712f32591b5af95f3fe43421f704">isNull</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#abf4db491627843669c3d26263f18ef72">isEmpty</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceTagLib.html#a0d56da3fb97ff5e823c2c4b3aea77e25">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#ae497a9e2f33d7e7cd78558a6991db707">checksum</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceTagLib.html#a0d56da3fb97ff5e823c2c4b3aea77e25">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a1f234fafaa7cb0f13c85a7aed996e4a4">toUInt</a> (bool mostSignificantByteFirst=true) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a792be96ea5c9edb1d1eb9e987d0f0b1d">toShort</a> (bool mostSignificantByteFirst=true) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#aa504bf38f98c782647ea46fbe7c9dc5c">toUShort</a> (bool mostSignificantByteFirst=true) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a398ca4acfe99175547dd239a2ed83730">toLongLong</a> (bool mostSignificantByteFirst=true) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a2ec096b29dc0f9222ca393692fae128a">operator[]</a> (int index) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a6c078f5864c875eb49a0e900336191e2">operator[]</a> (int index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a9e891841a6c5259b177498a19a91c758">operator==</a> (const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;v) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a3918f3327686bc80a6022bf66fb86124">operator!=</a> (const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;v) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a0ae63d46b0a9ddd6971c40502cb7835f">operator==</a> (const char *s) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a0167694c169d832fa0b1012a5d62d89c">operator!=</a> (const char *s) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a264ff435cb7f79bd93ccdb1ba4d5c52f">operator&lt;</a> (const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;v) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a5c3f661ccc7cf8309089e9b3a284d3bc">operator&gt;</a> (const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;v) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a5de1892f12726bb4d50276abd8f64edc">operator+</a> (const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;v) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#ac612d7f38571456c5f0083e07df554cd">operator=</a> (const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a4a8204c1556dee0a7f330962b8587381">operator=</a> (char c)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#aba5947f410bee90e1cd36a0dd931113d">operator=</a> (const char *data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#ae9839e48c11619907ad618a4d7399e76">toHex</a> () const </td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a680335d571501172e98df012aae52335">fromUInt</a> (<a class="el" href="namespaceTagLib.html#a0d56da3fb97ff5e823c2c4b3aea77e25">uint</a> value, bool mostSignificantByteFirst=true)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a162543bf4b280468a677799686178522">fromShort</a> (short value, bool mostSignificantByteFirst=true)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a51b81a576453f38fb816294f1e77a76d">fromLongLong</a> (long long value, bool mostSignificantByteFirst=true)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a2782f08a6b8350c4e5f17548a60b5495">fromCString</a> (const char *s, <a class="el" href="namespaceTagLib.html#a0d56da3fb97ff5e823c2c4b3aea77e25">uint</a> length=0xffffffff)</td></tr>
<tr><td colspan="2"><h2><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a7593a608427eb6f855c4dc48558ad8a4">null</a></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#aed0573f25ee917a40d6cd242b3115ae0">detach</a> ()</td></tr>
<tr><td colspan="2"><h2><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td colspan="2">(Note that these are not member functions.) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TAGLIB_EXPORT std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a36db251bf327d8f00dcee07367fd7cd5">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classTagLib_1_1ByteVector.html">TagLib::ByteVector</a> &amp;v)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>A byte vector. </p>
<p>This class provides a byte vector with some methods that are useful for tagging purposes. Many of the search functions are tailored to what is useful for finding tag related paterns in a data array. </p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="af6e5b2614dacfc049b5b6e32063d4aa1"></a><!-- doxytag: member="TagLib::ByteVector::ByteVector" ref="af6e5b2614dacfc049b5b6e32063d4aa1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TagLib::ByteVector::ByteVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Constructs an empty byte vector. </p>

</div>
</div>
<a class="anchor" id="a6e3bb27e43b76a1e3e40c8364ad7158c"></a><!-- doxytag: member="TagLib::ByteVector::ByteVector" ref="a6e3bb27e43b76a1e3e40c8364ad7158c" args="(uint size, char value=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TagLib::ByteVector::ByteVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceTagLib.html#a0d56da3fb97ff5e823c2c4b3aea77e25">uint</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>value</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a vector of size <em>size</em> with all values set to <em>value</em> by default. </p>

</div>
</div>
<a class="anchor" id="a613e5467e1b582775f98eed1e2f6c1ef"></a><!-- doxytag: member="TagLib::ByteVector::ByteVector" ref="a613e5467e1b582775f98eed1e2f6c1ef" args="(const ByteVector &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TagLib::ByteVector::ByteVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Contructs a byte vector that is a copy of <em>v</em>. </p>

</div>
</div>
<a class="anchor" id="aa286e2ae6447e55e85ef855838d10c96"></a><!-- doxytag: member="TagLib::ByteVector::ByteVector" ref="aa286e2ae6447e55e85ef855838d10c96" args="(char c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TagLib::ByteVector::ByteVector </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Contructs a byte vector that contains <em>c</em>. </p>

</div>
</div>
<a class="anchor" id="ad3fee04984a628e55cf480d56604e9ce"></a><!-- doxytag: member="TagLib::ByteVector::ByteVector" ref="ad3fee04984a628e55cf480d56604e9ce" args="(const char *data, uint length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TagLib::ByteVector::ByteVector </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceTagLib.html#a0d56da3fb97ff5e823c2c4b3aea77e25">uint</a>&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Constructs a byte vector that copies <em>data</em> for up to <em>length</em> bytes. </p>

</div>
</div>
<a class="anchor" id="aa3cd4cd25e6b8fbd6a795005478b08e0"></a><!-- doxytag: member="TagLib::ByteVector::ByteVector" ref="aa3cd4cd25e6b8fbd6a795005478b08e0" args="(const char *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TagLib::ByteVector::ByteVector </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Constructs a byte vector that copies <em>data</em> up to the first null byte. The behavior is undefined if <em>data</em> is not null terminated. This is particularly useful for constructing byte arrays from string constants. </p>

</div>
</div>
<a class="anchor" id="a34b45e9a86728313ddef12a037acc73d"></a><!-- doxytag: member="TagLib::ByteVector::~ByteVector" ref="a34b45e9a86728313ddef12a037acc73d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual TagLib::ByteVector::~ByteVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroys this <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a> instance. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aff38e54fa184e9cf0c77182db200a6e4"></a><!-- doxytag: member="TagLib::ByteVector::append" ref="aff38e54fa184e9cf0c77182db200a6e4" args="(const ByteVector &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a>&amp; TagLib::ByteVector::append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Appends <em>v</em> to the end of the <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a>. </p>

</div>
</div>
<a class="anchor" id="a4db625889dc6281783ae25d3733e0919"></a><!-- doxytag: member="TagLib::ByteVector::at" ref="a4db625889dc6281783ae25d3733e0919" args="(uint index) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char TagLib::ByteVector::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceTagLib.html#a0d56da3fb97ff5e823c2c4b3aea77e25">uint</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This essentially performs the same as <a class="el" href="classTagLib_1_1ByteVector.html#a2ec096b29dc0f9222ca393692fae128a">operator[]()</a>, but instead of causing a runtime error if the index is out of bounds, it will return a null byte. </p>

</div>
</div>
<a class="anchor" id="a99848a9fbcb7b39e16866a881e2b115f"></a><!-- doxytag: member="TagLib::ByteVector::begin" ref="a99848a9fbcb7b39e16866a881e2b115f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Iterator TagLib::ByteVector::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns an Iterator that points to the front of the vector. </p>

</div>
</div>
<a class="anchor" id="aab4c8b26244d1efc6f392062a3146e41"></a><!-- doxytag: member="TagLib::ByteVector::begin" ref="aab4c8b26244d1efc6f392062a3146e41" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ConstIterator TagLib::ByteVector::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns a ConstIterator that points to the front of the vector. </p>

</div>
</div>
<a class="anchor" id="ae497a9e2f33d7e7cd78558a6991db707"></a><!-- doxytag: member="TagLib::ByteVector::checksum" ref="ae497a9e2f33d7e7cd78558a6991db707" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceTagLib.html#a0d56da3fb97ff5e823c2c4b3aea77e25">uint</a> TagLib::ByteVector::checksum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns a CRC checksum of the byte vector's data. </p>

</div>
</div>
<a class="anchor" id="a2e2e95380834f3a55d49df208befe88c"></a><!-- doxytag: member="TagLib::ByteVector::clear" ref="a2e2e95380834f3a55d49df208befe88c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a>&amp; TagLib::ByteVector::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Clears the data. </p>

</div>
</div>
<a class="anchor" id="ab62281faaa15a69073f4b830ad576213"></a><!-- doxytag: member="TagLib::ByteVector::containsAt" ref="ab62281faaa15a69073f4b830ad576213" args="(const ByteVector &amp;pattern, uint offset, uint patternOffset=0, uint patternLength=0xffffffff) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TagLib::ByteVector::containsAt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceTagLib.html#a0d56da3fb97ff5e823c2c4b3aea77e25">uint</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceTagLib.html#a0d56da3fb97ff5e823c2c4b3aea77e25">uint</a>&#160;</td>
          <td class="paramname"><em>patternOffset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceTagLib.html#a0d56da3fb97ff5e823c2c4b3aea77e25">uint</a>&#160;</td>
          <td class="paramname"><em>patternLength</em> = <code>0xffffffff</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Checks to see if the vector contains the <em>pattern</em> starting at position <em>offset</em>. Optionally, if you only want to search for part of the pattern you can specify an offset within the pattern to start from. Also, you can specify to only check for the first <em>patternLength</em> bytes of <em>pattern</em> with the <em>patternLength</em> argument. </p>

</div>
</div>
<a class="anchor" id="affe39991f59ce978639ef48400b0891b"></a><!-- doxytag: member="TagLib::ByteVector::data" ref="affe39991f59ce978639ef48400b0891b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* TagLib::ByteVector::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns a pointer to the internal data structure which may not be modified. </p>

</div>
</div>
<a class="anchor" id="a55d40ed1e9b9749e3895c845f1f26901"></a><!-- doxytag: member="TagLib::ByteVector::data" ref="a55d40ed1e9b9749e3895c845f1f26901" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* TagLib::ByteVector::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns a pointer to the internal data structure.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Care should be taken when modifying this data structure as it is easy to corrupt the <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a> when doing so. Specifically, while the data may be changed, its length may not be. </dd></dl>

</div>
</div>
<a class="anchor" id="aed0573f25ee917a40d6cd242b3115ae0"></a><!-- doxytag: member="TagLib::ByteVector::detach" ref="aed0573f25ee917a40d6cd242b3115ae0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TagLib::ByteVector::detach </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="acc7a47ae21af8e3a02be6346c078f2b8"></a><!-- doxytag: member="TagLib::ByteVector::end" ref="acc7a47ae21af8e3a02be6346c078f2b8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ConstIterator TagLib::ByteVector::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns a ConstIterator that points to the back of the vector. </p>

</div>
</div>
<a class="anchor" id="a53a1f28d1a51f7351733f2ef22090c34"></a><!-- doxytag: member="TagLib::ByteVector::end" ref="a53a1f28d1a51f7351733f2ef22090c34" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Iterator TagLib::ByteVector::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns an Iterator that points to the back of the vector. </p>

</div>
</div>
<a class="anchor" id="a68505e709c3cc3061ca0de7a04251f46"></a><!-- doxytag: member="TagLib::ByteVector::endsWith" ref="a68505e709c3cc3061ca0de7a04251f46" args="(const ByteVector &amp;pattern) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TagLib::ByteVector::endsWith </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true if the vector ends with <em>pattern</em>. </p>

</div>
</div>
<a class="anchor" id="afe9d03a684dbba770e2871a2dfe1d55a"></a><!-- doxytag: member="TagLib::ByteVector::endsWithPartialMatch" ref="afe9d03a684dbba770e2871a2dfe1d55a" args="(const ByteVector &amp;pattern) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TagLib::ByteVector::endsWithPartialMatch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Checks for a partial match of <em>pattern</em> at the end of the vector. It returns the offset of the partial match within the vector, or -1 if the pattern is not found. This method is particularly useful when searching for patterns that start in one vector and end in another. When combined with <a class="el" href="classTagLib_1_1ByteVector.html#a5f330306a73bbd23d89f7c14a2126456">startsWith()</a> it can be used to find a pattern that overlaps two buffers.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This will not match the complete pattern at the end of the string; use <a class="el" href="classTagLib_1_1ByteVector.html#a68505e709c3cc3061ca0de7a04251f46">endsWith()</a> for that. </dd></dl>

</div>
</div>
<a class="anchor" id="a557c662441974ba731bfdf9a360df5ce"></a><!-- doxytag: member="TagLib::ByteVector::find" ref="a557c662441974ba731bfdf9a360df5ce" args="(const ByteVector &amp;pattern, uint offset=0, int byteAlign=1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TagLib::ByteVector::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceTagLib.html#a0d56da3fb97ff5e823c2c4b3aea77e25">uint</a>&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>byteAlign</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Searches the <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a> for <em>pattern</em> starting at <em>offset</em> and returns the offset. Returns -1 if the pattern was not found. If <em>byteAlign</em> is specified the pattern will only be matched if it starts on a byte divisible by <em>byteAlign</em> (starting from <em>offset</em>). </p>

</div>
</div>
<a class="anchor" id="a2782f08a6b8350c4e5f17548a60b5495"></a><!-- doxytag: member="TagLib::ByteVector::fromCString" ref="a2782f08a6b8350c4e5f17548a60b5495" args="(const char *s, uint length=0xffffffff)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> TagLib::ByteVector::fromCString </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceTagLib.html#a0d56da3fb97ff5e823c2c4b3aea77e25">uint</a>&#160;</td>
          <td class="paramname"><em>length</em> = <code>0xffffffff</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns a <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a> based on the CString <em>s</em>. </p>

</div>
</div>
<a class="anchor" id="a51b81a576453f38fb816294f1e77a76d"></a><!-- doxytag: member="TagLib::ByteVector::fromLongLong" ref="a51b81a576453f38fb816294f1e77a76d" args="(long long value, bool mostSignificantByteFirst=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> TagLib::ByteVector::fromLongLong </td>
          <td>(</td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mostSignificantByteFirst</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a 8 byte <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a> based on <em>value</em>. If <em>mostSignificantByteFirst</em> is true, then this will operate left to right in building the <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a>. For example if <em>mostSignificantByteFirst</em> is true then $00 00 00 01 == 0x0000000000000001 == 1, if false, $01 00 00 00 00 00 00 00 == 0x0100000000000000 == 1.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classTagLib_1_1ByteVector.html#a398ca4acfe99175547dd239a2ed83730">toLongLong()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a162543bf4b280468a677799686178522"></a><!-- doxytag: member="TagLib::ByteVector::fromShort" ref="a162543bf4b280468a677799686178522" args="(short value, bool mostSignificantByteFirst=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> TagLib::ByteVector::fromShort </td>
          <td>(</td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mostSignificantByteFirst</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a 2 byte <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a> based on <em>value</em>. If <em>mostSignificantByteFirst</em> is true, then this will operate left to right in building the <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a>. For example if <em>mostSignificantByteFirst</em> is true then $00 01 == 0x0001 == 1, if false, $01 00 == 0x0100 == 1.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classTagLib_1_1ByteVector.html#a792be96ea5c9edb1d1eb9e987d0f0b1d">toShort()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a680335d571501172e98df012aae52335"></a><!-- doxytag: member="TagLib::ByteVector::fromUInt" ref="a680335d571501172e98df012aae52335" args="(uint value, bool mostSignificantByteFirst=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> TagLib::ByteVector::fromUInt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceTagLib.html#a0d56da3fb97ff5e823c2c4b3aea77e25">uint</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mostSignificantByteFirst</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a 4 byte <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a> based on <em>value</em>. If <em>mostSignificantByteFirst</em> is true, then this will operate left to right in building the <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a>. For example if <em>mostSignificantByteFirst</em> is true then $00 00 00 01 == 0x00000001 == 1, if false, $01 00 00 00 == 0x01000000 == 1.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classTagLib_1_1ByteVector.html#a1f234fafaa7cb0f13c85a7aed996e4a4">toUInt()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abf4db491627843669c3d26263f18ef72"></a><!-- doxytag: member="TagLib::ByteVector::isEmpty" ref="abf4db491627843669c3d26263f18ef72" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TagLib::ByteVector::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true if the <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a> is empty.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classTagLib_1_1ByteVector.html#ad35dc30632085e7696660de9694bbc24">size()</a> </dd>
<dd>
<a class="el" href="classTagLib_1_1ByteVector.html#a3ab3712f32591b5af95f3fe43421f704">isNull()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3ab3712f32591b5af95f3fe43421f704"></a><!-- doxytag: member="TagLib::ByteVector::isNull" ref="a3ab3712f32591b5af95f3fe43421f704" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TagLib::ByteVector::isNull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true if the vector is null.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>A vector may be empty without being null. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classTagLib_1_1ByteVector.html#abf4db491627843669c3d26263f18ef72">isEmpty()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab347f103e6c2bba92fdf491031dc46ba"></a><!-- doxytag: member="TagLib::ByteVector::mid" ref="ab347f103e6c2bba92fdf491031dc46ba" args="(uint index, uint length=0xffffffff) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> TagLib::ByteVector::mid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceTagLib.html#a0d56da3fb97ff5e823c2c4b3aea77e25">uint</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceTagLib.html#a0d56da3fb97ff5e823c2c4b3aea77e25">uint</a>&#160;</td>
          <td class="paramname"><em>length</em> = <code>0xffffffff</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns a byte vector made up of the bytes starting at <em>index</em> and for <em>length</em> bytes. If <em>length</em> is not specified it will return the bytes from <em>index</em> to the end of the vector. </p>

</div>
</div>
<a class="anchor" id="a3918f3327686bc80a6022bf66fb86124"></a><!-- doxytag: member="TagLib::ByteVector::operator!=" ref="a3918f3327686bc80a6022bf66fb86124" args="(const ByteVector &amp;v) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TagLib::ByteVector::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true if this <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a> and <em>v</em> are not equal. </p>

</div>
</div>
<a class="anchor" id="a0167694c169d832fa0b1012a5d62d89c"></a><!-- doxytag: member="TagLib::ByteVector::operator!=" ref="a0167694c169d832fa0b1012a5d62d89c" args="(const char *s) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TagLib::ByteVector::operator!= </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true if this <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a> and the null terminated C string <em>s</em> do not contain the same data. </p>

</div>
</div>
<a class="anchor" id="a5de1892f12726bb4d50276abd8f64edc"></a><!-- doxytag: member="TagLib::ByteVector::operator+" ref="a5de1892f12726bb4d50276abd8f64edc" args="(const ByteVector &amp;v) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> TagLib::ByteVector::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns a vector that is <em>v</em> appended to this vector. </p>

</div>
</div>
<a class="anchor" id="a264ff435cb7f79bd93ccdb1ba4d5c52f"></a><!-- doxytag: member="TagLib::ByteVector::operator&lt;" ref="a264ff435cb7f79bd93ccdb1ba4d5c52f" args="(const ByteVector &amp;v) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TagLib::ByteVector::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true if this <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a> is less than <em>v</em>. The value of the vectors is determined by evaluating the character from left to right, and in the event one vector is a superset of the other, the size is used. </p>

</div>
</div>
<a class="anchor" id="aba5947f410bee90e1cd36a0dd931113d"></a><!-- doxytag: member="TagLib::ByteVector::operator=" ref="aba5947f410bee90e1cd36a0dd931113d" args="(const char *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a>&amp; TagLib::ByteVector::operator= </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copies <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a> <em>v</em>. </p>

</div>
</div>
<a class="anchor" id="ac612d7f38571456c5f0083e07df554cd"></a><!-- doxytag: member="TagLib::ByteVector::operator=" ref="ac612d7f38571456c5f0083e07df554cd" args="(const ByteVector &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a>&amp; TagLib::ByteVector::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copies <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a> <em>v</em>. </p>

</div>
</div>
<a class="anchor" id="a4a8204c1556dee0a7f330962b8587381"></a><!-- doxytag: member="TagLib::ByteVector::operator=" ref="a4a8204c1556dee0a7f330962b8587381" args="(char c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a>&amp; TagLib::ByteVector::operator= </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copies <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a> <em>v</em>. </p>

</div>
</div>
<a class="anchor" id="a9e891841a6c5259b177498a19a91c758"></a><!-- doxytag: member="TagLib::ByteVector::operator==" ref="a9e891841a6c5259b177498a19a91c758" args="(const ByteVector &amp;v) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TagLib::ByteVector::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true if this <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a> and <em>v</em> are equal. </p>

</div>
</div>
<a class="anchor" id="a0ae63d46b0a9ddd6971c40502cb7835f"></a><!-- doxytag: member="TagLib::ByteVector::operator==" ref="a0ae63d46b0a9ddd6971c40502cb7835f" args="(const char *s) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TagLib::ByteVector::operator== </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true if this <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a> and the null terminated C string <em>s</em> contain the same data. </p>

</div>
</div>
<a class="anchor" id="a5c3f661ccc7cf8309089e9b3a284d3bc"></a><!-- doxytag: member="TagLib::ByteVector::operator&gt;" ref="a5c3f661ccc7cf8309089e9b3a284d3bc" args="(const ByteVector &amp;v) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TagLib::ByteVector::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true if this <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a> is greater than <em>v</em>. </p>

</div>
</div>
<a class="anchor" id="a2ec096b29dc0f9222ca393692fae128a"></a><!-- doxytag: member="TagLib::ByteVector::operator[]" ref="a2ec096b29dc0f9222ca393692fae128a" args="(int index) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char&amp; TagLib::ByteVector::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns a const refernence to the byte at <em>index</em>. </p>

</div>
</div>
<a class="anchor" id="a6c078f5864c875eb49a0e900336191e2"></a><!-- doxytag: member="TagLib::ByteVector::operator[]" ref="a6c078f5864c875eb49a0e900336191e2" args="(int index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char&amp; TagLib::ByteVector::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns a reference to the byte at <em>index</em>. </p>

</div>
</div>
<a class="anchor" id="adf2c71ba84454616e1310e6dc12f8aa8"></a><!-- doxytag: member="TagLib::ByteVector::replace" ref="adf2c71ba84454616e1310e6dc12f8aa8" args="(const ByteVector &amp;pattern, const ByteVector &amp;with)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a>&amp; TagLib::ByteVector::replace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>with</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Replaces <em>pattern</em> with <em>with</em> and returns a reference to the <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a> after the operation. This <em>does</em> modify the vector. </p>

</div>
</div>
<a class="anchor" id="add7490c1075ad2e119a164fb5491fd44"></a><!-- doxytag: member="TagLib::ByteVector::resize" ref="add7490c1075ad2e119a164fb5491fd44" args="(uint size, char padding=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a>&amp; TagLib::ByteVector::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceTagLib.html#a0d56da3fb97ff5e823c2c4b3aea77e25">uint</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>padding</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Resize the vector to <em>size</em>. If the vector is currently less than <em>size</em>, pad the remaining spaces with <em>padding</em>. Returns a reference to the resized vector. </p>

</div>
</div>
<a class="anchor" id="a46c984d49bda6a270f62d98b6a2933e4"></a><!-- doxytag: member="TagLib::ByteVector::rfind" ref="a46c984d49bda6a270f62d98b6a2933e4" args="(const ByteVector &amp;pattern, uint offset=0, int byteAlign=1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TagLib::ByteVector::rfind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceTagLib.html#a0d56da3fb97ff5e823c2c4b3aea77e25">uint</a>&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>byteAlign</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Searches the <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a> for <em>pattern</em> starting from either the end of the vector or <em>offset</em> and returns the offset. Returns -1 if the pattern was not found. If <em>byteAlign</em> is specified the pattern will only be matched if it starts on a byte divisible by <em>byteAlign</em> (starting from <em>offset</em>). </p>

</div>
</div>
<a class="anchor" id="a3749ede91c16089c33992649eb0522c8"></a><!-- doxytag: member="TagLib::ByteVector::setData" ref="a3749ede91c16089c33992649eb0522c8" args="(const char *data, uint length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a>&amp; TagLib::ByteVector::setData </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceTagLib.html#a0d56da3fb97ff5e823c2c4b3aea77e25">uint</a>&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the data for the byte array using the first <em>length</em> bytes of <em>data</em> </p>

</div>
</div>
<a class="anchor" id="af9a5128d1503ddaf6e6f780ce4eeb184"></a><!-- doxytag: member="TagLib::ByteVector::setData" ref="af9a5128d1503ddaf6e6f780ce4eeb184" args="(const char *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a>&amp; TagLib::ByteVector::setData </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the data for the byte array copies <em>data</em> up to the first null byte. The behavior is undefined if <em>data</em> is not null terminated. </p>

</div>
</div>
<a class="anchor" id="ad35dc30632085e7696660de9694bbc24"></a><!-- doxytag: member="TagLib::ByteVector::size" ref="ad35dc30632085e7696660de9694bbc24" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceTagLib.html#a0d56da3fb97ff5e823c2c4b3aea77e25">uint</a> TagLib::ByteVector::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the size of the array. </p>

</div>
</div>
<a class="anchor" id="a5f330306a73bbd23d89f7c14a2126456"></a><!-- doxytag: member="TagLib::ByteVector::startsWith" ref="a5f330306a73bbd23d89f7c14a2126456" args="(const ByteVector &amp;pattern) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TagLib::ByteVector::startsWith </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true if the vector starts with <em>pattern</em>. </p>

</div>
</div>
<a class="anchor" id="ae9839e48c11619907ad618a4d7399e76"></a><!-- doxytag: member="TagLib::ByteVector::toHex" ref="ae9839e48c11619907ad618a4d7399e76" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> TagLib::ByteVector::toHex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns a hex-encoded copy of the byte vector. </p>

</div>
</div>
<a class="anchor" id="a398ca4acfe99175547dd239a2ed83730"></a><!-- doxytag: member="TagLib::ByteVector::toLongLong" ref="a398ca4acfe99175547dd239a2ed83730" args="(bool mostSignificantByteFirst=true) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long long TagLib::ByteVector::toLongLong </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mostSignificantByteFirst</em> = <code>true</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Converts the first 8 bytes of the vector to a (signed) long long.</p>
<p>If <em>mostSignificantByteFirst</em> is true this will operate left to right evaluating the integer. For example if <em>mostSignificantByteFirst</em> is true then $00 00 00 00 00 00 00 01 == 0x0000000000000001 == 1, if false, $01 00 00 00 00 00 00 00 == 0x0100000000000000 == 1.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classTagLib_1_1ByteVector.html#a680335d571501172e98df012aae52335">fromUInt()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a792be96ea5c9edb1d1eb9e987d0f0b1d"></a><!-- doxytag: member="TagLib::ByteVector::toShort" ref="a792be96ea5c9edb1d1eb9e987d0f0b1d" args="(bool mostSignificantByteFirst=true) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short TagLib::ByteVector::toShort </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mostSignificantByteFirst</em> = <code>true</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Converts the first 2 bytes of the vector to a short.</p>
<p>If <em>mostSignificantByteFirst</em> is true this will operate left to right evaluating the integer. For example if <em>mostSignificantByteFirst</em> is true then $00 $01 == 0x0001 == 1, if false, $01 00 == 0x01000000 == 1.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classTagLib_1_1ByteVector.html#a162543bf4b280468a677799686178522">fromShort()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1f234fafaa7cb0f13c85a7aed996e4a4"></a><!-- doxytag: member="TagLib::ByteVector::toUInt" ref="a1f234fafaa7cb0f13c85a7aed996e4a4" args="(bool mostSignificantByteFirst=true) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceTagLib.html#a0d56da3fb97ff5e823c2c4b3aea77e25">uint</a> TagLib::ByteVector::toUInt </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mostSignificantByteFirst</em> = <code>true</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Converts the first 4 bytes of the vector to an unsigned integer.</p>
<p>If <em>mostSignificantByteFirst</em> is true this will operate left to right evaluating the integer. For example if <em>mostSignificantByteFirst</em> is true then $00 $00 $00 $01 == 0x00000001 == 1, if false, $01 00 00 00 == 0x01000000 == 1.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classTagLib_1_1ByteVector.html#a680335d571501172e98df012aae52335">fromUInt()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa504bf38f98c782647ea46fbe7c9dc5c"></a><!-- doxytag: member="TagLib::ByteVector::toUShort" ref="aa504bf38f98c782647ea46fbe7c9dc5c" args="(bool mostSignificantByteFirst=true) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short TagLib::ByteVector::toUShort </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mostSignificantByteFirst</em> = <code>true</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Converts the first 2 bytes of the vector to a unsigned short.</p>
<p>If <em>mostSignificantByteFirst</em> is true this will operate left to right evaluating the integer. For example if <em>mostSignificantByteFirst</em> is true then $00 $01 == 0x0001 == 1, if false, $01 00 == 0x01000000 == 1.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classTagLib_1_1ByteVector.html#a162543bf4b280468a677799686178522">fromShort()</a> </dd></dl>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a36db251bf327d8f00dcee07367fd7cd5"></a><!-- doxytag: member="TagLib::ByteVector::operator&lt;&lt;" ref="a36db251bf327d8f00dcee07367fd7cd5" args="(std::ostream &amp;s, const TagLib::ByteVector &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TAGLIB_EXPORT std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTagLib_1_1ByteVector.html">TagLib::ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Streams the <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a> <em>v</em> to the output stream <em>s</em>. </p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a7593a608427eb6f855c4dc48558ad8a4"></a><!-- doxytag: member="TagLib::ByteVector::null" ref="a7593a608427eb6f855c4dc48558ad8a4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> <a class="el" href="classTagLib_1_1ByteVector.html#a7593a608427eb6f855c4dc48558ad8a4">TagLib::ByteVector::null</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A static, empty <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a> which is convenient and fast (since returning an empty or "null" value does not require instantiating a new <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a>). </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="tbytevector_8h_source.html">tbytevector.h</a></li>
</ul>
</div>

